name: Android Kernel CI

on:
  workflow_dispatch:
    inputs:
      kernel_source:
        description: Kernel source git URL
        required: true
        type: string
      kernel_branch:
        description: Kernel branch
        required: true
        type: string
      device:
        description: Device codename (for naming only)
        required: true
        type: string
      defconfig:
        description: Kernel defconfig (e.g. vendor/moonstone_defconfig)
        required: true
        type: string
      kernelsu_next:
        description: Enable KernelSU-Next
        required: true
        default: "false"
        type: choice
        options: ["false", "true"]

jobs:
  build:
    runs-on: ubuntu-22.04
    permissions:
      contents: write

    env:
      ARCH: arm64
      SUBARCH: arm64
      TG_TOKEN: ${{ secrets.TG_TOKEN }}
      TG_CHAT_ID: ${{ secrets.TG_CHAT_ID }}
      CCACHE_DIR: ${{ github.workspace }}/.ccache

    steps:
      - name: Checkout this repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 1
          submodules: recursive

      - name: Install dependencies
        run: |
          set -euo pipefail
          sudo apt-get update
          sudo apt-get install -y \
            bc bison build-essential ccache curl flex git \
            libelf-dev libssl-dev make python3 rsync unzip wget zip zstd \
            dwarves xz-utils

      - name: Restore Proton Clang cache
        uses: actions/cache@v4
        with:
          path: clang
          key: proton-clang-v1

      - name: Setup Proton Clang
        run: |
          set -euo pipefail
          if [ ! -x clang/bin/clang ]; then
            git clone --depth=1 https://github.com/kdrag0n/proton-clang clang
          fi

      - name: Restore ccache
        uses: actions/cache@v4
        with:
          path: .ccache
          key: ccache-${{ runner.os }}-${{ inputs.kernel_branch }}-${{ inputs.defconfig }}-${{ github.sha }}
          restore-keys: |
            ccache-${{ runner.os }}-${{ inputs.kernel_branch }}-${{ inputs.defconfig }}-
            ccache-${{ runner.os }}-

      - name: Clone Kernel Source
        run: |
          set -euo pipefail
          git clone --depth=1 -b "${{ inputs.kernel_branch }}" "${{ inputs.kernel_source }}" kernel

      - name: KernelSU-Next
        if: ${{ inputs.kernelsu_next == 'true' }}
        run: |
          set -euo pipefail
          cd kernel
          curl -LSs https://raw.githubusercontent.com/KernelSU-Next/KernelSU-Next/next/kernel/setup.sh | bash -
          echo "KernelSU-Next patch applied. git status:"
          git status --porcelain || true

      - name: Patch unsupported Polly flags (auto)
        run: |
          set -euo pipefail
          export PATH="${GITHUB_WORKSPACE}/clang/bin:${PATH}"

          if grep -RIn --include='Makefile*' --include='*.mk' --include='*.make' -- '-polly-' kernel >/dev/null 2>&1; then
            echo "Found -polly-* flags in kernel tree. Checking toolchain compatibility..."
            if ! clang -c -x c /dev/null -o /tmp/polly_test.o -polly-reschedule=1 >/dev/null 2>&1; then
              echo "Clang does not accept -polly-*. Stripping from Makefiles..."
              find kernel -type f \( -name 'Makefile' -o -name 'Makefile.*' -o -name '*.mk' -o -name '*.make' \) -print0 \
                | xargs -0 sed -i -E \
                  -e 's/[[:space:]]-mllvm[[:space:]]+-polly-[^[:space:]]+//g' \
                  -e 's/[[:space:]]-polly-[^[:space:]]+//g'
            else
              echo "Clang accepts -polly-*; leaving flags untouched."
            fi
          else
            echo "No -polly-* flags found."
          fi

      - name: Telegram Build Start
        if: ${{ env.TG_TOKEN != '' && env.TG_CHAT_ID != '' }}
        run: |
          set -euo pipefail
          curl -sS -X POST "https://api.telegram.org/bot${TG_TOKEN}/sendMessage" \
            -d chat_id="${TG_CHAT_ID}" \
            --data-urlencode text=$'Kernel Build Started\nDevice: ${{ inputs.device }}\nBranch: ${{ inputs.kernel_branch }}\nDefconfig: ${{ inputs.defconfig }}\nKernelSU-Next: ${{ inputs.kernelsu_next }}'

      - name: Build Kernel
        run: |
          set -euo pipefail
          export PATH="${GITHUB_WORKSPACE}/clang/bin:${PATH}"

          ccache -M 5G || true
          ccache -z || true

          export CC="ccache clang"
          export CXX="ccache clang++"
          export LD=ld.lld
          export AR=llvm-ar
          export NM=llvm-nm
          export OBJCOPY=llvm-objcopy
          export OBJDUMP=llvm-objdump
          export STRIP=llvm-strip

          cd kernel
          mkdir -p out

          # Generate .config
          make O=out "${{ inputs.defconfig }}"

          # Config sync (non-interactive) + fallback without failing on `yes` SIGPIPE
          if make O=out olddefconfig; then
            :
          else
            set +e
            set +o pipefail
            yes "" 2>/dev/null | make O=out oldconfig
            MAKE_RC="${PIPESTATUS[1]}"
            set -o pipefail
            set -e
            if [ "$MAKE_RC" -ne 0 ]; then
              echo "SUCCESS=0" >> "$GITHUB_ENV"
              echo "oldconfig failed with code $MAKE_RC" > error.log
              exit 0
            fi
          fi

          # ---------------------------
          # KernelSU-Next integration (robust, universal-ish)
          # ---------------------------
          if [ "${{ inputs.kernelsu_next }}" = "true" ]; then
            echo "KernelSU-Next requested: verifying Kconfig integration & enabling..."

            # Ensure scripts/config is executable if present
            [ -f scripts/config ] && chmod +x scripts/config || true

            # 1) Find KernelSU Kconfig path (commonly drivers/kernelsu/Kconfig)
            KSU_KCONFIG=""
            if [ -f drivers/kernelsu/Kconfig ]; then
              KSU_KCONFIG="drivers/kernelsu/Kconfig"
            else
              KSU_KCONFIG="$(find drivers -maxdepth 5 -type f -name Kconfig 2>/dev/null | grep -i kernelsu | head -n1 || true)"
            fi

            # If setup.sh used a different location, try broader search
            if [ -z "$KSU_KCONFIG" ]; then
              KSU_KCONFIG="$(find . -maxdepth 6 -type f -name Kconfig 2>/dev/null | grep -i kernelsu | head -n1 || true)"
            fi

            if [ -z "$KSU_KCONFIG" ]; then
              echo "SUCCESS=0" >> "$GITHUB_ENV"
              {
                echo "ERROR: KernelSU-Next selected but no KernelSU Kconfig file was found."
                echo "setup.sh ran, but the kernel tree doesn't contain a kernelsu*/Kconfig."
                echo "Hints:"
                echo "- The kernel may be incompatible with KernelSU-Next integration method."
                echo "- Or setup.sh didn't patch this tree properly."
              } > error.log
              exit 0
            fi

            echo "Detected KernelSU Kconfig: $KSU_KCONFIG"

            # 2) Ensure drivers/Kconfig sources it if it lives under drivers/
            if [ -f drivers/Kconfig ] && [[ "$KSU_KCONFIG" == drivers/* ]]; then
              if ! grep -qF "$KSU_KCONFIG" drivers/Kconfig; then
                echo "Linking KernelSU Kconfig into drivers/Kconfig..."
                printf '\nsource "%s"\n' "$KSU_KCONFIG" >> drivers/Kconfig
              fi
            fi

            # 3) Detect main symbol name from that Kconfig
            # Prefer common names first if present.
            KSU_SYM="$(grep -m1 -E '^[[:space:]]*config[[:space:]]+(KSU_NEXT|KERNELSU|KSU)\b' "$KSU_KCONFIG" 2>/dev/null | awk '{print $2}' || true)"
            if [ -z "$KSU_SYM" ]; then
              KSU_SYM="$(grep -m1 -E '^[[:space:]]*config[[:space:]]+[A-Z0-9_]+' "$KSU_KCONFIG" 2>/dev/null | awk '{print $2}' || true)"
            fi
            [ -z "$KSU_SYM" ] && KSU_SYM="KSU"

            echo "Detected KernelSU symbol: CONFIG_${KSU_SYM}"

            # 4) Ensure drivers/Makefile builds the subdir when CONFIG_<SYM>=y (if under drivers)
            if [[ "$KSU_KCONFIG" == drivers/* ]] && [ -f drivers/Makefile ]; then
              KSU_DIR="$(dirname "$KSU_KCONFIG")"
              KSU_SUBDIR="$(basename "$KSU_DIR")"

              if ! grep -qE "obj-\\$\\(CONFIG_${KSU_SYM}\\).*${KSU_SUBDIR}/" drivers/Makefile; then
                echo "Linking KernelSU subdir into drivers/Makefile..."
                printf '\nobj-$(CONFIG_%s) += %s/\n' "$KSU_SYM" "$KSU_SUBDIR" >> drivers/Makefile
              fi
            fi

            # 5) Refresh config now that Kconfig tree may have changed
            make O=out olddefconfig || true

            # 6) Force enable built-in (=y)
            if [ -x scripts/config ]; then
              scripts/config --file out/.config -e "$KSU_SYM" || true
            else
              echo "CONFIG_${KSU_SYM}=y" >> out/.config
            fi

            make O=out olddefconfig || true

            echo "KernelSU-related .config lines:"
            grep -E "^(CONFIG_${KSU_SYM}=|# CONFIG_${KSU_SYM} is not set)" out/.config || true

            # 7) If still not enabled, mark failure but keep pipeline functionality intact
            if ! grep -q "^CONFIG_${KSU_SYM}=y" out/.config; then
              echo "SUCCESS=0" >> "$GITHUB_ENV"
              {
                echo "ERROR: KernelSU-Next selected but CONFIG_${KSU_SYM} could not be enabled."
                echo "Detected Kconfig: $KSU_KCONFIG"
                echo "Detected symbol:  $KSU_SYM"
                echo
                echo "Top lines from KernelSU Kconfig (for debugging):"
                sed -n '1,120p' "$KSU_KCONFIG" || true
                echo
                echo "Matching .config lines:"
                grep -E "^(CONFIG_${KSU_SYM}=|# CONFIG_${KSU_SYM} is not set)" out/.config || true
              } > error.log
              exit 0
            fi

            echo "KSU_SYMBOL=${KSU_SYM}" >> "$GITHUB_ENV"
            echo "KernelSU-Next enabled: CONFIG_${KSU_SYM}=y"
          fi

          START="$(date +%s)"
          if make -j"$(nproc)" O=out LLVM=1 LLVM_IAS=1 2>&1 | tee build.log; then
            echo "SUCCESS=1" >> "$GITHUB_ENV"
          else
            echo "SUCCESS=0" >> "$GITHUB_ENV"
            cp -f build.log error.log
          fi
          END="$(date +%s)"
          echo "BUILD_TIME=$((END-START))" >> "$GITHUB_ENV"

          KVER="$(make -s kernelversion | tr -d '\n' || true)"
          CLANG_VER="$(clang --version | head -n1 | tr -d '\n' || true)"
          printf "KERNEL_VERSION=%s\n" "${KVER:-unknown}" >> "$GITHUB_ENV"
          printf "CLANG_VERSION=%s\n" "${CLANG_VER:-unknown}" >> "$GITHUB_ENV"

          ccache -s || true

      - name: Detect GKI
        run: |
          set -euo pipefail
          if [ -f kernel/out/.config ] && grep -q '^CONFIG_GKI=y' kernel/out/.config; then
            echo "KERNEL_TYPE=GKI" >> "$GITHUB_ENV"
          else
            echo "KERNEL_TYPE=NON-GKI" >> "$GITHUB_ENV"
          fi

      - name: Ensure AnyKernel core exists
        if: env.SUCCESS == '1'
        run: |
          set -euo pipefail
          test -f anykernel/anykernel.sh || { echo "Missing: anykernel/anykernel.sh"; exit 1; }

          if [ ! -f anykernel/tools/ak3-core.sh ]; then
            rm -rf anykernel_upstream
            git clone --depth=1 https://github.com/osm0sis/AnyKernel3 anykernel_upstream
            rsync -a --exclude 'anykernel.sh' anykernel_upstream/ anykernel/
            rm -rf anykernel_upstream
          fi

          chmod 755 anykernel/anykernel.sh || true

      - name: Package AnyKernel3
        if: env.SUCCESS == '1'
        run: |
          set -euo pipefail
          BOOTDIR="kernel/out/arch/arm64/boot"
          test -d "$BOOTDIR" || { echo "Missing boot dir: $BOOTDIR"; exit 1; }

          rm -f anykernel/Image* anykernel/zImage 2>/dev/null || true

          KIMG=""
          for f in Image.gz-dtb Image-dtb Image.gz Image.lz4 Image zImage; do
            if [ -f "${BOOTDIR}/${f}" ]; then
              KIMG="$f"
              cp -f "${BOOTDIR}/${f}" "anykernel/${f}"
              break
            fi
          done

          if [ -z "$KIMG" ]; then
            echo "No kernel image found in ${BOOTDIR}"
            ls -la "$BOOTDIR" || true
            exit 1
          fi

          KSTR="Custom Kernel ${{ inputs.device }} ${KERNEL_VERSION}"
          KSTR_ESC="${KSTR//&/\\&}"
          sed -i "s|^[[:space:]]*kernel.string=.*|kernel.string=${KSTR_ESC}|" anykernel/anykernel.sh
          sed -i "s|^[[:space:]]*device.name1=.*|device.name1=${{ inputs.device }}|" anykernel/anykernel.sh

          ZIP_NAME="Kernel-${{ inputs.device }}-${{ github.run_id }}-${{ github.run_attempt }}.zip"
          (cd anykernel && zip -r9 "../${ZIP_NAME}" . -x "*.git*" )

          echo "ZIP_NAME=${ZIP_NAME}" >> "$GITHUB_ENV"
          echo "KERNEL_IMAGE_FILE=${KIMG}" >> "$GITHUB_ENV"

      - name: Upload artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: kernel-${{ inputs.device }}-${{ github.run_id }}-${{ github.run_attempt }}
          path: |
            Kernel-*.zip
            kernel/build.log
            kernel/error.log
          if-no-files-found: warn

      - name: GitHub Release
        if: env.SUCCESS == '1'
        uses: softprops/action-gh-release@v2
        with:
          tag_name: build-${{ github.run_id }}-${{ github.run_attempt }}
          name: Kernel-${{ inputs.device }} (run ${{ github.run_id }}/${{ github.run_attempt }})
          files: |
            ${{ env.ZIP_NAME }}
            kernel/build.log

      - name: Telegram Success
        if: ${{ env.SUCCESS == '1' && env.TG_TOKEN != '' && env.TG_CHAT_ID != '' }}
        run: |
          set -euo pipefail
          MSG=$'Kernel Build Success\nDevice: ${{ inputs.device }}\nType: '"$KERNEL_TYPE"$'\nLinux: '"$KERNEL_VERSION"$'\nToolchain: '"$CLANG_VERSION"$'\nTime: '"$BUILD_TIME"'s\nImage: '"$KERNEL_IMAGE_FILE"$'\nArtifact: '"$ZIP_NAME"
          curl -sS -X POST "https://api.telegram.org/bot${TG_TOKEN}/sendMessage" \
            -d chat_id="${TG_CHAT_ID}" \
            --data-urlencode text="$MSG"

          curl -sS -F chat_id="$TG_CHAT_ID" \
            -F document=@"${ZIP_NAME}" \
            "https://api.telegram.org/bot${TG_TOKEN}/sendDocument"

          curl -sS -F chat_id="$TG_CHAT_ID" \
            -F document=@kernel/build.log \
            "https://api.telegram.org/bot${TG_TOKEN}/sendDocument"

      - name: Telegram Failure
        if: ${{ env.SUCCESS == '0' && env.TG_TOKEN != '' && env.TG_CHAT_ID != '' }}
        run: |
          set -euo pipefail
          test -f kernel/error.log || cp -f kernel/build.log kernel/error.log || true
          curl -sS -F chat_id="${TG_CHAT_ID}" \
            -F document=@kernel/error.log \
            -F caption="‚ùå Kernel build FAILED | Device=${{ inputs.device }} | KernelSU-Next=${{ inputs.kernelsu_next }}" \
            "https://api.telegram.org/bot${TG_TOKEN}/sendDocument"

      - name: Mark workflow failed if kernel build failed
        if: env.SUCCESS == '0'
        run: exit 1
