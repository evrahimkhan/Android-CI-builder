name: Android Kernel CI

on:
  workflow_dispatch:
    inputs:
      kernel_source:
        description: Kernel source git URL
        required: true
        type: string
        pattern: ^https://[a-zA-Z0-9][a-zA-Z0-9._-]*(:[0-9]+)?/[a-zA-Z0-9._-]+/[a-zA-Z0-9._-]*\.git$
      kernel_branch:
        description: Kernel branch
        required: true
        type: string
        pattern: ^[a-zA-Z0-9/_.-]+$
      device:
        description: Device codename (for naming only)
        required: true
        type: string
        pattern: ^[a-zA-Z0-9_-]+$
      defconfig:
        description: Kernel defconfig (e.g. vendor/moonstone_defconfig)
        required: true
        type: string
        pattern: ^[a-zA-Z0-9/_.-]+$

      enable_custom_config:
        description: Enable custom Kconfig branding
        required: true
        default: "false"
        type: choice
        options: ["false", "true"]
      config_localversion:
        description: CONFIG_LOCALVERSION
        required: false
        default: "-CI"
        type: string
        pattern: ^[a-zA-Z0-9_+.-]*$
      config_default_hostname:
        description: CONFIG_DEFAULT_HOSTNAME
        required: false
        default: "CI Builder"
        type: string
        pattern: ^[a-zA-Z0-9 _.-]+$
      config_uname_override_string:
        description: CONFIG_UNAME_OVERRIDE_STRING
        required: false
        default: ""
        type: string
        pattern: ^[a-zA-Z0-9 _.-]*$
      config_cc_version_text:
        description: Optional override for CONFIG_CC_VERSION_TEXT (blank = auto)
        required: false
        default: ""
        type: string
        pattern: ^[a-zA-Z0-9 _.-]*$

      enable_nethunter_config:
        description: Enable NetHunter kernel configuration
        required: true
        default: "false"
        type: choice
        options: ["false", "true"]
      nethunter_config_level:
        description: NetHunter configuration level (basic includes USB/Bluetooth/networking, full adds WiFi drivers/SDR/CAN/NFS)
        required: false
        default: "basic"
        type: choice
        options: ["basic", "full"]

      enable_rtl8188eus_driver:
        description: Enable RTL8188eus USB WiFi driver (built-in)
        required: true
        default: "false"
        type: choice
        options: ["false", "true"]


jobs:
  build:
    runs-on: ubuntu-22.04
    timeout-minutes: 60
    permissions:
      contents: write

    env:
      ARCH: arm64
      SUBARCH: arm64
      TG_TOKEN: ${{ secrets.TG_TOKEN }}
      TG_CHAT_ID: ${{ secrets.TG_CHAT_ID }}
      CCACHE_DIR: ${{ github.workspace }}/.ccache

    steps:
      - name: Checkout this repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 1
          submodules: recursive

      - name: Make CI scripts executable
        shell: bash
        run: |
          set -euo pipefail
          LOG_DIR="${{ github.workspace }}/kernel"
          LOG_FILE="$LOG_DIR/build.log"
          ERR_FILE="$LOG_DIR/error.log"
          mkdir -p "$LOG_DIR"
          
          ts() { date -u '+%Y-%m-%d %H:%M:%S UTC'; }
          log() { printf "[%s] %s\n" "$(ts)" "$*"; }
          log_step() { printf "[%s] [STEP] %s\n" "$(ts)" "$*" | tee -a "$LOG_FILE"; }
          
          log_step "Starting: Making CI scripts executable"
          chmod +x ci/*.sh 2>&1 | tee -a "$LOG_FILE"
          EXIT_CODE=${PIPESTATUS[0]:-$?}
          
          if [ $EXIT_CODE -eq 0 ]; then
            log_step "Completed: Made CI scripts executable"
          else
            log_step "FAILED: chmod (exit code: $EXIT_CODE)"
            printf "[%s] ERROR: chmod failed\n\nFULL OUTPUT:\n%s\n" "$(ts)" "$(cat "$LOG_FILE")" >> "$ERR_FILE"
            exit $EXIT_CODE
          fi

      - name: Run NetHunter Config Tests
        if: inputs.enable_nethunter_config == 'true' || inputs.enable_rtl8188eus_driver == 'true'
        shell: bash
        run: |
          set -euo pipefail
          LOG_DIR="${{ github.workspace }}/kernel"
          LOG_FILE="$LOG_DIR/build.log"
          ERR_FILE="$LOG_DIR/error.log"
          mkdir -p "$LOG_DIR"
          
          ts() { date -u '+%Y-%m-%d %H:%M:%S UTC'; }
          log() { printf "[%s] %s\n" "$(ts)" "$*"; }
          log_step() { printf "[%s] [STEP] %s\n" "$(ts)" "$*" | tee -a "$LOG_FILE"; }
          
          # Export RTL8188EUS_ENABLED for the test
          export RTL8188EUS_ENABLED="${{ inputs.enable_rtl8188eus_driver }}"
          
          log_step "Starting: NetHunter Configuration Tests"
          bash ci/test_nethunter_config.sh 2>&1 | tee -a "$LOG_FILE"
          EXIT_CODE=${PIPESTATUS[0]:-$?}
          
          if [ $EXIT_CODE -eq 0 ]; then
            log_step "Completed: NetHunter Configuration Tests"
          else
            log_step "FAILED: NetHunter tests (exit code: $EXIT_CODE)"
            printf "[%s] ERROR: NetHunter tests failed\n\nFULL OUTPUT:\n%s\n" "$(ts)" "$(cat "$LOG_FILE")" >> "$ERR_FILE"
            exit $EXIT_CODE
          fi

      - name: Install dependencies
        shell: bash
        run: |
          set -euo pipefail
          LOG_DIR="${{ github.workspace }}/kernel"
          LOG_FILE="$LOG_DIR/build.log"
          ERR_FILE="$LOG_DIR/error.log"
          mkdir -p "$LOG_DIR"
          
          ts() { date -u '+%Y-%m-%d %H:%M:%S UTC'; }
          log() { printf "[%s] %s\n" "$(ts)" "$*"; }
          log_step() { printf "[%s] [STEP] %s\n" "$(ts)" "$*" | tee -a "$LOG_FILE"; }
          
          log_step "Starting: Install System Dependencies"
          bash ci/install_deps.sh 2>&1 | tee -a "$LOG_FILE"
          EXIT_CODE=${PIPESTATUS[0]:-$?}
          
          if [ $EXIT_CODE -eq 0 ]; then
            log_step "Completed: Install System Dependencies"
          else
            log_step "FAILED: apt-get install (exit code: $EXIT_CODE)"
            printf "[%s] ERROR: Dependency installation failed\n\nFULL OUTPUT:\n%s\n" "$(ts)" "$(cat "$LOG_FILE")" >> "$ERR_FILE"
            exit $EXIT_CODE
          fi

      - name: Restore GCC cache
        uses: actions/cache@v4
        with:
          path: gcc
          key: gcc-arm-${{ inputs.kernel_source }}-${{ inputs.kernel_branch }}-${{ hashFiles('.github/workflows/**') }}
          restore-keys: |
            gcc-arm-${{ inputs.kernel_source }}-${{ inputs.kernel_branch }}-
            gcc-arm-${{ inputs.kernel_source }}-
            gcc-arm-

      - name: Setup GCC ARM Toolchain
        shell: bash
        run: |
          set -euo pipefail
          LOG_DIR="${{ github.workspace }}/kernel"
          LOG_FILE="$LOG_DIR/build.log"
          ERR_FILE="$LOG_DIR/error.log"
          mkdir -p "$LOG_DIR"
          
          ts() { date -u '+%Y-%m-%d %H:%M:%S UTC'; }
          log() { printf "[%s] %s\n" "$(ts)" "$*"; }
          log_step() { printf "[%s] [STEP] %s\n" "$(ts)" "$*" | tee -a "$LOG_FILE"; }
          
          log_step "Starting: Setup GCC ARM Toolchain"
          bash ci/setup_gcc.sh 2>&1 | tee -a "$LOG_FILE"
          EXIT_CODE=${PIPESTATUS[0]:-$?}
          
          if [ $EXIT_CODE -eq 0 ]; then
            log_step "Completed: Setup GCC ARM Toolchain"
          else
            log_step "FAILED: GCC ARM Toolchain setup (exit code: $EXIT_CODE)"
            printf "[%s] ERROR: GCC ARM Toolchain setup failed\n\nFULL OUTPUT:\n%s\n" "$(ts)" "$(cat "$LOG_FILE")" >> "$ERR_FILE"
            exit $EXIT_CODE
          fi

      - name: Restore ccache
        uses: actions/cache@v4
        with:
          path: .ccache
          key: ccache-${{ runner.os }}-${{ inputs.kernel_branch }}-${{ inputs.defconfig }}-${{ github.sha }}
          restore-keys: |
            ccache-${{ runner.os }}-${{ inputs.kernel_branch }}-${{ inputs.defconfig }}-
            ccache-${{ runner.os }}-

      - name: Clone Kernel Source
        shell: bash
        run: |
          set -euo pipefail
          LOG_DIR="${{ github.workspace }}/kernel"
          LOG_FILE="$LOG_DIR/build.log"
          ERR_FILE="$LOG_DIR/error.log"
          mkdir -p "$LOG_DIR"
          
          ts() { date -u '+%Y-%m-%d %H:%M:%S UTC'; }
          log() { printf "[%s] %s\n" "$(ts)" "$*"; }
          log_step() { printf "[%s] [STEP] %s\n" "$(ts)" "$*" | tee -a "$LOG_FILE"; }
          
          log_step "Starting: Clone Kernel (${{ inputs.kernel_source }}#${{ inputs.kernel_branch }})"
          
          # Create log directory FIRST, before any cleanup
          mkdir -p "$LOG_DIR"
          
          # Now remove kernel dir (log dir is already created, so we won't have race)
          if [ -d "${{ github.workspace }}/kernel" ]; then
            log "Kernel directory already exists, removing..."
            rm -rf "${{ github.workspace }}/kernel"
          fi
          
          # Recreate log directory after rm (in case it was removed)
          mkdir -p "$LOG_DIR"
          
          bash ci/clone_kernel.sh "${{ inputs.kernel_source }}" "${{ inputs.kernel_branch }}" 2>&1 | tee -a "$LOG_FILE"
          EXIT_CODE=${PIPESTATUS[0]:-$?}
          
          # Verify clone succeeded
          if [ $EXIT_CODE -eq 0 ] && [ -f "${{ github.workspace }}/kernel/Makefile" ]; then
            log_step "Completed: Clone Kernel"
            log "Kernel Makefile found at: ${{ github.workspace }}/kernel/Makefile"
          elif [ $EXIT_CODE -eq 0 ]; then
            log_step "Clone returned success but Makefile not found"
            EXIT_CODE=1
          else
            log_step "FAILED: Kernel clone (exit code: $EXIT_CODE)"
          fi
          
          if [ $EXIT_CODE -ne 0 ]; then
            printf "[%s] ERROR: Kernel clone failed\n\nFULL OUTPUT:\n%s\n" "$(ts)" "$(cat "$LOG_FILE")" >> "$ERR_FILE"
            exit $EXIT_CODE
          fi

      - name: Telegram Build Start
        if: ${{ env.TG_TOKEN != '' && env.TG_CHAT_ID != '' }}
        shell: bash
        env:
          NETHUNTER_ENABLED: ${{ inputs.enable_nethunter_config }}
          NETHUNTER_CONFIG_LEVEL: ${{ inputs.nethunter_config_level }}
        run: |
          set -euo pipefail
          LOG_DIR="${{ github.workspace }}/kernel"
          LOG_FILE="$LOG_DIR/build.log"
          ERR_FILE="$LOG_DIR/error.log"
          mkdir -p "$LOG_DIR"
          
          ts() { date -u '+%Y-%m-%d %H:%M:%S UTC'; }
          log() { printf "[%s] %s\n" "$(ts)" "$*"; }
          log_step() { printf "[%s] [STEP] %s\n" "$(ts)" "$*" | tee -a "$LOG_FILE"; }
          
          log_step "Starting: Telegram Build Start Notification"
          bash ci/telegram.sh start "${{ inputs.device }}" "${{ inputs.kernel_branch }}" "${{ inputs.defconfig }}" "" "" "" "${{ inputs.enable_custom_config }}" "${{ inputs.config_localversion }}" "${{ inputs.config_default_hostname }}" "${{ inputs.config_uname_override_string }}" "${{ inputs.config_cc_version_text }}" 2>&1 | tee -a "$LOG_FILE"
          EXIT_CODE=${PIPESTATUS[0]:-$?}
          
          if [ $EXIT_CODE -eq 0 ]; then
            log_step "Completed: Telegram Build Start Notification"
          else
            log_step "WARN: Telegram notification failed (exit code: $EXIT_CODE)"
          fi

      - name: Build Kernel (First Attempt)
        id: build_first
        shell: bash
        run: |
          set -euo pipefail
          LOG_DIR="${{ github.workspace }}/kernel"
          LOG_FILE="$LOG_DIR/build.log"
          ERR_FILE="$LOG_DIR/error.log"
          mkdir -p "$LOG_DIR"
          
          ts() { date -u '+%Y-%m-%d %H:%M:%S UTC'; }
          log() { printf "[%s] %s\n" "$(ts)" "$*"; }
          log_step() { printf "[%s] [STEP] %s\n" "$(ts)" "$*" | tee -a "$LOG_FILE"; }
          
          # Export env vars so subprocess can access them
          export CUSTOM_CONFIG_ENABLED="${{ inputs.enable_custom_config }}"
          export CFG_LOCALVERSION="${{ inputs.config_localversion }}"
          export CFG_DEFAULT_HOSTNAME="${{ inputs.config_default_hostname }}"
          export CFG_UNAME_OVERRIDE_STRING="${{ inputs.config_uname_override_string }}"
          export CFG_CC_VERSION_TEXT="${{ inputs.config_cc_version_text }}"
          export NETHUNTER_ENABLED="${{ inputs.enable_nethunter_config }}"
          export NETHUNTER_CONFIG_LEVEL="${{ inputs.nethunter_config_level }}"
          export RTL8188EUS_ENABLED="${{ inputs.enable_rtl8188eus_driver }}"
          
          log_step "Starting: Build Kernel (${{ inputs.defconfig }})"
          bash ci/build_kernel.sh "${{ inputs.defconfig }}" 2>&1 | tee -a "$LOG_FILE"
          EXIT_CODE=${PIPESTATUS[0]:-$?}
          
           if [ $EXIT_CODE -eq 0 ]; then
             echo "FIRST_BUILD_SUCCESS=true" >> "$GITHUB_ENV"
             echo "SUCCESS=1" >> "$GITHUB_ENV"
             log_step "Completed: Build Kernel"
           else
             echo "FIRST_BUILD_SUCCESS=false" >> "$GITHUB_ENV"
             echo "SUCCESS=0" >> "$GITHUB_ENV"
             log_step "FAILED: Build Kernel (exit code: $EXIT_CODE)"
             printf "[%s] ERROR: Initial kernel build failed\n\nFULL OUTPUT:\n%s\n" "$(ts)" "$(cat "$LOG_FILE")" >> "$ERR_FILE"
             exit $EXIT_CODE
           fi

      - name: Patch unsupported Polly flags (on build failure)
        if: env.FIRST_BUILD_SUCCESS == 'false'
        shell: bash
        run: |
          set -euo pipefail
          LOG_DIR="${{ github.workspace }}/kernel"
          LOG_FILE="$LOG_DIR/build.log"
          ERR_FILE="$LOG_DIR/error.log"
          mkdir -p "$LOG_DIR"
          
          ts() { date -u '+%Y-%m-%d %H:%M:%S UTC'; }
          log() { printf "[%s] %s\n" "$(ts)" "$*"; }
          log_step() { printf "[%s] [STEP] %s\n" "$(ts)" "$*" | tee -a "$LOG_FILE"; }
          
          log_step "Starting: Patch Polly Flags"
          bash ci/patch_polly.sh 2>&1 | tee -a "$LOG_FILE"
          EXIT_CODE=${PIPESTATUS[0]:-$?}
          
          if [ $EXIT_CODE -eq 0 ]; then
            log_step "Completed: Patch Polly Flags"
          else
            log_step "FAILED: Polly patch (exit code: $EXIT_CODE)"
            printf "[%s] ERROR: Polly patch failed\n\nFULL OUTPUT:\n%s\n" "$(ts)" "$(cat "$LOG_FILE")" >> "$ERR_FILE"
            exit $EXIT_CODE
          fi

      - name: Build Kernel (Retry After Polly Patch)
        if: env.FIRST_BUILD_SUCCESS == 'false'
        id: build_retry
        shell: bash
        run: |
          set -euo pipefail
          LOG_DIR="${{ github.workspace }}/kernel"
          LOG_FILE="$LOG_DIR/build.log"
          ERR_FILE="$LOG_DIR/error.log"
          mkdir -p "$LOG_DIR"
          
          ts() { date -u '+%Y-%m-%d %H:%M:%S UTC'; }
          log() { printf "[%s] %s\n" "$(ts)" "$*"; }
          log_step() { printf "[%s] [STEP] %s\n" "$(ts)" "$*" | tee -a "$LOG_FILE"; }
          
          # Export env vars so subprocess can access them
          export CUSTOM_CONFIG_ENABLED="${{ inputs.enable_custom_config }}"
          export CFG_LOCALVERSION="${{ inputs.config_localversion }}"
          export CFG_DEFAULT_HOSTNAME="${{ inputs.config_default_hostname }}"
          export CFG_UNAME_OVERRIDE_STRING="${{ inputs.config_uname_override_string }}"
          export CFG_CC_VERSION_TEXT="${{ inputs.config_cc_version_text }}"
          export NETHUNTER_ENABLED="${{ inputs.enable_nethunter_config }}"
          export NETHUNTER_CONFIG_LEVEL="${{ inputs.nethunter_config_level }}"
          export RTL8188EUS_ENABLED="${{ inputs.enable_rtl8188eus_driver }}"
          
          log_step "Starting: Retry Build Kernel"
          bash ci/build_kernel.sh "${{ inputs.defconfig }}" 2>&1 | tee -a "$LOG_FILE"
          EXIT_CODE=${PIPESTATUS[0]:-$?}
          
           if [ $EXIT_CODE -eq 0 ]; then
             echo "SUCCESS=1" >> "$GITHUB_ENV"
             log_step "Completed: Retry Build Kernel"
           else
             echo "SUCCESS=0" >> "$GITHUB_ENV"
             log_step "FAILED: Retry Build Kernel (exit code: $EXIT_CODE)"
             printf "[%s] ERROR: Retry build failed\n\nFULL OUTPUT:\n%s\n" "$(ts)" "$(cat "$LOG_FILE")" >> "$ERR_FILE"
             exit $EXIT_CODE
           fi

      - name: Detect GKI
        shell: bash
        run: |
          set -euo pipefail
          LOG_DIR="${{ github.workspace }}/kernel"
          LOG_FILE="$LOG_DIR/build.log"
          ERR_FILE="$LOG_DIR/error.log"
          mkdir -p "$LOG_DIR"
          
          ts() { date -u '+%Y-%m-%d %H:%M:%S UTC'; }
          log() { printf "[%s] %s\n" "$(ts)" "$*"; }
          log_step() { printf "[%s] [STEP] %s\n" "$(ts)" "$*" | tee -a "$LOG_FILE"; }
          
          log_step "Starting: Detect GKI"
          bash ci/detect_gki.sh 2>&1 | tee -a "$LOG_FILE"
          EXIT_CODE=${PIPESTATUS[0]:-$?}
          
          if [ $EXIT_CODE -eq 0 ]; then
            log_step "Completed: Detect GKI"
          else
            log_step "WARN: GKI detection had issues (exit code: $EXIT_CODE)"
          fi

      - name: Verify NetHunter Configuration
        if: ${{ inputs.enable_nethunter_config == 'true' || inputs.enable_rtl8188eus_driver == 'true' }}
        shell: bash
        env:
          NETHUNTER_ENABLED: ${{ inputs.enable_nethunter_config }}
          NETHUNTER_CONFIG_LEVEL: ${{ inputs.nethunter_config_level }}
          RTL8188EUS_ENABLED: ${{ inputs.enable_rtl8188eus_driver }}
        run: |
          set -euo pipefail
          LOG_DIR="${{ github.workspace }}/kernel"
          LOG_FILE="$LOG_DIR/build.log"
          ERR_FILE="$LOG_DIR/error.log"
          mkdir -p "$LOG_DIR"
          
          ts() { date -u '+%Y-%m-%d %H:%M:%S UTC'; }
          log() { printf "[%s] %s\n" "$(ts)" "$*"; }
          log_step() { printf "[%s] [STEP] %s\n" "$(ts)" "$*" | tee -a "$LOG_FILE"; }
          
          log_step "Starting: Verify NetHunter Configuration"
          bash ci/verify_nethunter_config.sh "${{ inputs.nethunter_config_level }}" 2>&1 | tee -a "$LOG_FILE"
          EXIT_CODE=${PIPESTATUS[0]:-$?}
          
          if [ $EXIT_CODE -eq 1 ]; then
            log_step "CRITICAL: Missing required NetHunter configs"
            printf "[%s] ERROR: Critical NetHunter configs missing\n\nFULL OUTPUT:\n%s\n" "$(ts)" "$(cat "$LOG_FILE")" >> "$ERR_FILE"
            exit 1
          elif [ $EXIT_CODE -eq 2 ]; then
            log_step "WARN: Optional configs missing (acceptable)"
          else
            log_step "Completed: Verify NetHunter Configuration"
          fi

      - name: Ensure AnyKernel core exists
        if: env.SUCCESS == '1'
        shell: bash
        run: |
          set -euo pipefail
          LOG_DIR="${{ github.workspace }}/kernel"
          LOG_FILE="$LOG_DIR/build.log"
          ERR_FILE="$LOG_DIR/error.log"
          mkdir -p "$LOG_DIR"
          
          ts() { date -u '+%Y-%m-%d %H:%M:%S UTC'; }
          log() { printf "[%s] %s\n" "$(ts)" "$*"; }
          log_step() { printf "[%s] [STEP] %s\n" "$(ts)" "$*" | tee -a "$LOG_FILE"; }
          
          log_step "Starting: Ensure AnyKernel3"
          bash ci/ensure_anykernel_core.sh 2>&1 | tee -a "$LOG_FILE"
          EXIT_CODE=${PIPESTATUS[0]:-$?}
          
          if [ $EXIT_CODE -eq 0 ]; then
            log_step "Completed: Ensure AnyKernel3"
          else
            log_step "FAILED: AnyKernel3 (exit code: $EXIT_CODE)"
            printf "[%s] ERROR: AnyKernel3 setup failed\n\nFULL OUTPUT:\n%s\n" "$(ts)" "$(cat "$LOG_FILE")" >> "$ERR_FILE"
            exit $EXIT_CODE
          fi

      - name: Package AnyKernel ZIP
        if: env.SUCCESS == '1'
        shell: bash
        env:
          NETHUNTER_ENABLED: ${{ inputs.enable_nethunter_config }}
          NETHUNTER_CONFIG_LEVEL: ${{ inputs.nethunter_config_level }}
        run: |
          set -euo pipefail
          LOG_DIR="${{ github.workspace }}/kernel"
          LOG_FILE="$LOG_DIR/build.log"
          ERR_FILE="$LOG_DIR/error.log"
          mkdir -p "$LOG_DIR"
          
          ts() { date -u '+%Y-%m-%d %H:%M:%S UTC'; }
          log() { printf "[%s] %s\n" "$(ts)" "$*"; }
          log_step() { printf "[%s] [STEP] %s\n" "$(ts)" "$*" | tee -a "$LOG_FILE"; }
          
          log_step "Starting: Package AnyKernel ZIP (${{ inputs.device }})"
          bash ci/package_anykernel.sh "${{ inputs.device }}" 2>&1 | tee -a "$LOG_FILE"
          EXIT_CODE=${PIPESTATUS[0]:-$?}
          
          if [ $EXIT_CODE -eq 0 ]; then
            log_step "Completed: Package AnyKernel ZIP"
          else
            log_step "FAILED: Package AnyKernel ZIP (exit code: $EXIT_CODE)"
            printf "[%s] ERROR: AnyKernel packaging failed\n\nFULL OUTPUT:\n%s\n" "$(ts)" "$(cat "$LOG_FILE")" >> "$ERR_FILE"
            exit $EXIT_CODE
          fi

      - name: Upload artifacts
        if: always()
        uses: actions/upload-artifact@v5
        with:
          name: kernel-${{ inputs.device }}-${{ github.run_id }}-${{ github.run_attempt }}
          path: |
            Kernel-*.zip
            kernel/build.log
            kernel/error.log
          if-no-files-found: warn

      - name: GitHub Release
        if: env.SUCCESS == '1'
        uses: softprops/action-gh-release@v2.5.0
        with:
          tag_name: build-${{ github.run_id }}-${{ github.run_attempt }}
          name: Kernel-${{ inputs.device }} (run ${{ github.run_id }}/${{ github.run_attempt }})
          fail_on_unmatched_files: false
          generate_release_notes: false
          body: |
            ## Build Information
            - **Device:** ${{ inputs.device }}
            - **Kernel:** ${{ env.KERNEL_VERSION != '' && env.KERNEL_VERSION || 'unknown' }}
            - **Clang:** ${{ env.CLANG_VERSION != '' && env.CLANG_VERSION || 'unknown' }}
            - **Build Time:** ${{ env.BUILD_TIME != '' && env.BUILD_TIME || '0' }}s
            - **Variant:** ${{ env.ZIP_VARIANT != '' && env.ZIP_VARIANT || 'normal' }}
            - **Git SHA:** ${{ github.sha }}

            ## Artifacts
            - Kernel-*.zip
            - build.log
          files: |
            Kernel-*.zip
            kernel/build.log

      - name: Telegram Success
        if: ${{ env.SUCCESS == '1' && env.TG_TOKEN != '' && env.TG_CHAT_ID != '' }}
        shell: bash
        env:
          NETHUNTER_ENABLED: ${{ inputs.enable_nethunter_config }}
          NETHUNTER_CONFIG_LEVEL: ${{ inputs.nethunter_config_level }}
        run: |
          set -euo pipefail
          LOG_DIR="${{ github.workspace }}/kernel"
          LOG_FILE="$LOG_DIR/build.log"
          ERR_FILE="$LOG_DIR/error.log"
          
          ts() { date -u '+%Y-%m-%d %H:%M:%S UTC'; }
          log() { printf "[%s] %s\n" "$(ts)" "$*"; }
          log_step() { printf "[%s] [STEP] %s\n" "$(ts)" "$*" | tee -a "$LOG_FILE"; }
          
          log_step "Starting: Telegram Success Notification"
          bash ci/telegram.sh success "${{ inputs.device }}" 2>&1 | tee -a "$LOG_FILE"
          
          upload_log_telegram() {
            local file="$1"
            local caption="$2"
            local max_size=$((50 * 1024 * 1024))
            if [ -f "$file" ]; then
              local file_size=$(stat -c%s "$file" 2>/dev/null || echo 0)
              if [ "$file_size" -gt "$max_size" ]; then
                tail -c $((max_size - 5242880)) "$file" > "${file}.trunc" && mv "${file}.trunc" "$file"
                caption="$caption (truncated to 50MB)"
              fi
              curl -sS --max-time 120 -X POST "https://api.telegram.org/bot${TG_TOKEN}/sendDocument" \
                -F chat_id="${TG_CHAT_ID}" \
                -F document="@${file}" \
                -F caption="${caption}" || true
            fi
          }
          
          upload_log_telegram "$LOG_FILE" "Build successful! Full build log."
          upload_log_telegram "$ERR_FILE" "Errors/Warnings log (if any)"
          
          log_step "Completed: Telegram Success Notification"

      - name: Telegram Failure
        if: ${{ env.SUCCESS == '0' && env.TG_TOKEN != '' && env.TG_CHAT_ID != '' }}
        shell: bash
        env:
          NETHUNTER_ENABLED: ${{ inputs.enable_nethunter_config }}
          NETHUNTER_CONFIG_LEVEL: ${{ inputs.nethunter_config_level }}
        run: |
          set -euo pipefail
          LOG_DIR="${{ github.workspace }}/kernel"
          LOG_FILE="$LOG_DIR/build.log"
          ERR_FILE="$LOG_DIR/error.log"
          
          ts() { date -u '+%Y-%m-%d %H:%M:%S UTC'; }
          log() { printf "[%s] %s\n" "$(ts)" "$*"; }
          log_step() { printf "[%s] [STEP] %s\n" "$(ts)" "$*" | tee -a "$LOG_FILE"; }
          
          log_step "Starting: Telegram Failure Notification"
          bash ci/telegram.sh failure "${{ inputs.device }}" 2>&1 | tee -a "$LOG_FILE"
          
          upload_log_telegram() {
            local file="$1"
            local caption="$2"
            local max_size=$((50 * 1024 * 1024))
            if [ -f "$file" ]; then
              local file_size=$(stat -c%s "$file" 2>/dev/null || echo 0)
              if [ "$file_size" -gt "$max_size" ]; then
                tail -c $((max_size - 5242880)) "$file" > "${file}.trunc" && mv "${file}.trunc" "$file"
                caption="$caption (truncated to 50MB)"
              fi
              curl -sS --max-time 120 -X POST "https://api.telegram.org/bot${TG_TOKEN}/sendDocument" \
                -F chat_id="${TG_CHAT_ID}" \
                -F document="@${file}" \
                -F caption="${caption}" || true
            fi
          }
          
          upload_log_telegram "$LOG_FILE" "Build failed! Full build log."
          upload_log_telegram "$ERR_FILE" "Error log"
          
          log_step "Completed: Telegram Failure Notification"

      - name: Mark workflow status
        shell: bash
        run: |
          set -euo pipefail
          LOG_DIR="${{ github.workspace }}/kernel"
          LOG_FILE="$LOG_DIR/build.log"
          ERR_FILE="$LOG_DIR/error.log"
          
          ts() { date -u '+%Y-%m-%d %H:%M:%S UTC'; }
          log() { printf "[%s] %s\n" "$(ts)" "$*"; }
          
          if [ "${{ env.SUCCESS }}" == "1" ]; then
            echo "✅ Kernel build completed successfully"
            log "BUILD SUCCESS"
          else
            echo "❌ Kernel build failed - see error.log for details"
            log "BUILD FAILED"
            exit 1
          fi
