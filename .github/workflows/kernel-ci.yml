name: Android Kernel CI

on:
  workflow_dispatch:
    inputs:
      kernel_source:
        description: Kernel source git URL
        required: true
        type: string
      kernel_branch:
        description: Kernel branch
        required: true
        type: string
      device:
        description: Device codename (for naming only)
        required: true
        type: string
      defconfig:
        description: Kernel defconfig (e.g. vendor/moonstone_defconfig)
        required: true
        type: string
      kernelsu_next:
        description: Enable KernelSU-Next
        required: true
        default: "false"
        type: choice
        options:
          - "false"
          - "true"

jobs:
  build:
    runs-on: ubuntu-22.04
    permissions:
      contents: write

    env:
      ARCH: arm64
      SUBARCH: arm64
      TG_TOKEN: ${{ secrets.TG_TOKEN }}
      TG_CHAT_ID: ${{ secrets.TG_CHAT_ID }}
      CCACHE_DIR: ${{ github.workspace }}/.ccache

    steps:
      - name: Checkout this repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 1
          submodules: recursive

      - name: Install dependencies
        shell: bash
        run: |
          set -euo pipefail
          sudo apt-get update
          sudo apt-get install -y \
            bc bison build-essential ccache curl flex git \
            libelf-dev libssl-dev make python3 rsync unzip wget zip zstd \
            dwarves xz-utils

      - name: Restore Proton Clang cache
        uses: actions/cache@v4
        with:
          path: clang
          key: proton-clang-v1

      - name: Setup Proton Clang
        shell: bash
        run: |
          set -euo pipefail
          if [ ! -x clang/bin/clang ]; then
            git clone --depth=1 https://github.com/kdrag0n/proton-clang clang
          fi

      - name: Restore ccache
        uses: actions/cache@v4
        with:
          path: .ccache
          key: ccache-${{ runner.os }}-${{ inputs.kernel_branch }}-${{ inputs.defconfig }}-${{ github.sha }}
          restore-keys: |
            ccache-${{ runner.os }}-${{ inputs.kernel_branch }}-${{ inputs.defconfig }}-
            ccache-${{ runner.os }}-

      - name: Clone Kernel Source
        shell: bash
        run: |
          set -euo pipefail
          git clone --depth=1 -b "${{ inputs.kernel_branch }}" "${{ inputs.kernel_source }}" kernel

      - name: KernelSU-Next
        if: ${{ inputs.kernelsu_next == 'true' }}
        shell: bash
        run: |
          set -euo pipefail
          cd kernel
          curl -LSs https://raw.githubusercontent.com/KernelSU-Next/KernelSU-Next/next/kernel/setup.sh | bash -
          echo "KernelSU-Next patch applied. git status:"
          git status --porcelain || true

      - name: Patch unsupported Polly flags (auto)
        shell: bash
        run: |
          set -euo pipefail
          export PATH="${GITHUB_WORKSPACE}/clang/bin:${PATH}"

          if grep -RIn --include='Makefile*' --include='*.mk' --include='*.make' -- '-polly-' kernel >/dev/null 2>&1; then
            echo "Found -polly-* flags in kernel tree. Checking toolchain compatibility..."
            if ! clang -c -x c /dev/null -o /tmp/polly_test.o -polly-reschedule=1 >/dev/null 2>&1; then
              echo "Clang does not accept -polly-*. Stripping from Makefiles..."
              find kernel -type f \( -name 'Makefile' -o -name 'Makefile.*' -o -name '*.mk' -o -name '*.make' \) -print0 \
                | xargs -0 sed -i -E \
                  -e 's/[[:space:]]-mllvm[[:space:]]+-polly-[^[:space:]]+//g' \
                  -e 's/[[:space:]]-polly-[^[:space:]]+//g'
            else
              echo "Clang accepts -polly-*; leaving flags untouched."
            fi
          else
            echo "No -polly-* flags found."
          fi

      - name: Telegram Build Start
        if: ${{ env.TG_TOKEN != '' && env.TG_CHAT_ID != '' }}
        shell: bash
        run: |
          set -euo pipefail
          curl -sS -X POST "https://api.telegram.org/bot${TG_TOKEN}/sendMessage" \
            -d chat_id="${TG_CHAT_ID}" \
            --data-urlencode text=$'Kernel Build Started\nDevice: ${{ inputs.device }}\nBranch: ${{ inputs.kernel_branch }}\nDefconfig: ${{ inputs.defconfig }}\nKernelSU-Next: ${{ inputs.kernelsu_next }}'

      - name: Build Kernel
        shell: bash
        run: |
          set -euo pipefail
          export PATH="${GITHUB_WORKSPACE}/clang/bin:${PATH}"

          ccache -M 5G || true
          ccache -z || true

          export CC="ccache clang"
          export CXX="ccache clang++"
          export LD=ld.lld
          export AR=llvm-ar
          export NM=llvm-nm
          export OBJCOPY=llvm-objcopy
          export OBJDUMP=llvm-objdump
          export STRIP=llvm-strip

          cd kernel
          mkdir -p out

          # Generate .config
          make O=out "${{ inputs.defconfig }}"

          # Fully non-interactive config sync:
          # Prevents EOF on new Kconfig questions; ignores `yes` SIGPIPE safely.
          set +e
          set +o pipefail
          yes "" 2>/dev/null | make O=out oldconfig
          CFG_RC="${PIPESTATUS[1]}"
          set -o pipefail
          set -e
          if [ "$CFG_RC" -ne 0 ]; then
            echo "SUCCESS=0" >> "$GITHUB_ENV"
            echo "ERROR: oldconfig failed with code $CFG_RC" > error.log
            exit 0
          fi

          if [ "${{ inputs.kernelsu_next }}" = "true" ]; then
            echo "KernelSU-Next requested: wiring Kconfig + enabling deps..."

            # Ensure scripts/config usable
            if [ -f scripts/config ]; then
              chmod +x scripts/config || true
            fi

            KSU_KCONFIG="drivers/kernelsu/Kconfig"
            if [ ! -f "$KSU_KCONFIG" ]; then
              echo "SUCCESS=0" >> "$GITHUB_ENV"
              echo "ERROR: KernelSU-Next selected but ${KSU_KCONFIG} not found." > error.log
              exit 0
            fi

            KSU_SYM="$(awk '/^[[:space:]]*config[[:space:]]+/ {print $2; exit}' "$KSU_KCONFIG" 2>/dev/null || true)"
            [ -z "$KSU_SYM" ] && KSU_SYM="KSU"
            echo "Detected KernelSU symbol: CONFIG_${KSU_SYM}"

            # Ensure Kconfig is actually sourced
            if [ -f Kconfig ] && ! grep -qF 'source "drivers/kernelsu/Kconfig"' Kconfig; then
              printf '\nsource "drivers/kernelsu/Kconfig"\n' >> Kconfig
            fi
            if [ -f drivers/Kconfig ] && ! grep -qF 'drivers/kernelsu/Kconfig' drivers/Kconfig; then
              printf '\nsource "drivers/kernelsu/Kconfig"\n' >> drivers/Kconfig
            fi

            # Ensure the directory is built when enabled
            if [ -f drivers/Makefile ] && [ -d drivers/kernelsu ] && ! grep -qE 'kernelsu/' drivers/Makefile; then
              printf '\nobj-$(CONFIG_%s) += kernelsu/\n' "$KSU_SYM" >> drivers/Makefile
            fi

            # Re-run oldconfig after introducing new Kconfig sources (non-interactive)
            set +e
            set +o pipefail
            yes "" 2>/dev/null | make O=out oldconfig
            CFG2_RC="${PIPESTATUS[1]}"
            set -o pipefail
            set -e
            if [ "$CFG2_RC" -ne 0 ]; then
              echo "SUCCESS=0" >> "$GITHUB_ENV"
              echo "ERROR: oldconfig after KSU wiring failed with code $CFG2_RC" > error.log
              exit 0
            fi

            # Enable deps + KSU (KSU depends on KPROBES)
            if [ -f scripts/config ]; then
              ./scripts/config --file out/.config -e KPROBES || true
              ./scripts/config --file out/.config -e KALLSYMS || true
              ./scripts/config --file out/.config -e KALLSYMS_ALL || true
              ./scripts/config --file out/.config -e "${KSU_SYM}" || true
            else
              echo "CONFIG_KPROBES=y" >> out/.config
              echo "CONFIG_KALLSYMS=y" >> out/.config
              echo "CONFIG_KALLSYMS_ALL=y" >> out/.config
              echo "CONFIG_${KSU_SYM}=y" >> out/.config
            fi

            set +e
            set +o pipefail
            yes "" 2>/dev/null | make O=out oldconfig
            CFG3_RC="${PIPESTATUS[1]}"
            set -o pipefail
            set -e
            if [ "$CFG3_RC" -ne 0 ]; then
              echo "SUCCESS=0" >> "$GITHUB_ENV"
              echo "ERROR: oldconfig after enabling KSU failed with code $CFG3_RC" > error.log
              exit 0
            fi

            echo "KSU line:"
            grep -E "^(CONFIG_${KSU_SYM}=|# CONFIG_${KSU_SYM} is not set)" out/.config || true
            echo "KPROBES line:"
            grep -E "^(CONFIG_KPROBES=|# CONFIG_KPROBES is not set)" out/.config || true

            # KernelSU compile compatibility patch for older kernels (e.g. 5.4)
            # Fixes: TWA_RESUME missing, put_task_struct undeclared
            if [ -f drivers/kernelsu/allowlist.c ]; then
              python3 - <<'PY'
from pathlib import Path

p = Path("drivers/kernelsu/allowlist.c")
s = p.read_text(errors="ignore")
marker = "KSU_NEXT_CI_COMPAT"
if marker in s:
    print("KernelSU compat patch already applied.")
    raise SystemExit(0)

compat = r'''
/* KSU_NEXT_CI_COMPAT: CI compatibility for older kernels/toolchains.
 * - Older kernels may not define TWA_RESUME (task_work notify mode).
 * - Some trees require <linux/sched/task.h> for put_task_struct().
 */
#ifndef TWA_RESUME
#define TWA_RESUME 1
#endif

#if defined(__has_include)
# if __has_include(<linux/sched/task.h>)
#  include <linux/sched/task.h>
# elif __has_include(<linux/sched.h>)
#  include <linux/sched.h>
# endif
#else
# include <linux/sched.h>
#endif
'''

lines = s.splitlines(True)

# insert after initial include block (first ~200 lines)
last_inc = -1
for i, line in enumerate(lines[:200]):
    if line.lstrip().startswith("#include"):
        last_inc = i

insert_at = last_inc + 1 if last_inc != -1 else 0
lines.insert(insert_at, compat + "\n")
p.write_text("".join(lines))
print("Applied KernelSU allowlist.c compatibility patch.")
PY
            fi
          fi

          START="$(date +%s)"
          if make -j"$(nproc)" O=out LLVM=1 LLVM_IAS=1 2>&1 | tee build.log; then
            echo "SUCCESS=1" >> "$GITHUB_ENV"
          else
            echo "SUCCESS=0" >> "$GITHUB_ENV"
            cp -f build.log error.log
          fi
          END="$(date +%s)"
          echo "BUILD_TIME=$((END-START))" >> "$GITHUB_ENV"

          KVER="$(make -s kernelversion | tr -d '\n' || true)"
          CLANG_VER="$(clang --version | head -n1 | tr -d '\n' || true)"
          printf "KERNEL_VERSION=%s\n" "${KVER:-unknown}" >> "$GITHUB_ENV"
          printf "CLANG_VERSION=%s\n" "${CLANG_VER:-unknown}" >> "$GITHUB_ENV"

          ccache -s || true

      - name: Detect GKI
        shell: bash
        run: |
          set -euo pipefail
          if [ -f kernel/out/.config ] && grep -q '^CONFIG_GKI=y' kernel/out/.config; then
            echo "KERNEL_TYPE=GKI" >> "$GITHUB_ENV"
          else
            echo "KERNEL_TYPE=NON-GKI" >> "$GITHUB_ENV"
          fi

      - name: Ensure AnyKernel core exists
        if: env.SUCCESS == '1'
        shell: bash
        run: |
          set -euo pipefail
          test -f anykernel/anykernel.sh || { echo "Missing: anykernel/anykernel.sh"; exit 1; }

          if [ ! -f anykernel/tools/ak3-core.sh ]; then
            rm -rf anykernel_upstream
            git clone --depth=1 https://github.com/osm0sis/AnyKernel3 anykernel_upstream
            rsync -a --exclude 'anykernel.sh' anykernel_upstream/ anykernel/
            rm -rf anykernel_upstream
          fi

          chmod 755 anykernel/anykernel.sh || true

      - name: Package AnyKernel3
        if: env.SUCCESS == '1'
        shell: bash
        run: |
          set -euo pipefail
          BOOTDIR="kernel/out/arch/arm64/boot"
          test -d "$BOOTDIR" || { echo "Missing boot dir: $BOOTDIR"; exit 1; }

          rm -f anykernel/Image* anykernel/zImage 2>/dev/null || true

          KIMG=""
          for f in Image.gz-dtb Image-dtb Image.gz Image.lz4 Image zImage; do
            if [ -f "${BOOTDIR}/${f}" ]; then
              KIMG="$f"
              cp -f "${BOOTDIR}/${f}" "anykernel/${f}"
              break
            fi
          done

          if [ -z "$KIMG" ]; then
            echo "No kernel image found in ${BOOTDIR}"
            ls -la "$BOOTDIR" || true
            exit 1
          fi

          KSTR="Custom Kernel ${{ inputs.device }} ${KERNEL_VERSION}"
          KSTR_ESC="${KSTR//&/\\&}"
          sed -i "s|^[[:space:]]*kernel.string=.*|kernel.string=${KSTR_ESC}|" anykernel/anykernel.sh
          sed -i "s|^[[:space:]]*device.name1=.*|device.name1=${{ inputs.device }}|" anykernel/anykernel.sh

          ZIP_NAME="Kernel-${{ inputs.device }}-${{ github.run_id }}-${{ github.run_attempt }}.zip"
          (cd anykernel && zip -r9 "../${ZIP_NAME}" . -x "*.git*" )

          echo "ZIP_NAME=${ZIP_NAME}" >> "$GITHUB_ENV"
          echo "KERNEL_IMAGE_FILE=${KIMG}" >> "$GITHUB_ENV"

      - name: Upload artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: kernel-${{ inputs.device }}-${{ github.run_id }}-${{ github.run_attempt }}
          path: |
            Kernel-*.zip
            kernel/build.log
            kernel/error.log
          if-no-files-found: warn

      - name: GitHub Release
        if: env.SUCCESS == '1'
        uses: softprops/action-gh-release@v2
        with:
          tag_name: build-${{ github.run_id }}-${{ github.run_attempt }}
          name: Kernel-${{ inputs.device }} (run ${{ github.run_id }}/${{ github.run_attempt }})
          files: |
            ${{ env.ZIP_NAME }}
            kernel/build.log

      - name: Telegram Success
        if: ${{ env.SUCCESS == '1' && env.TG_TOKEN != '' && env.TG_CHAT_ID != '' }}
        shell: bash
        run: |
          set -euo pipefail
          MSG=$'Kernel Build Success\nDevice: ${{ inputs.device }}\nType: '"$KERNEL_TYPE"$'\nLinux: '"$KERNEL_VERSION"$'\nToolchain: '"$CLANG_VERSION"$'\nTime: '"$BUILD_TIME"'s\nImage: '"$KERNEL_IMAGE_FILE"$'\nArtifact: '"$ZIP_NAME"
          curl -sS -X POST "https://api.telegram.org/bot${TG_TOKEN}/sendMessage" \
            -d chat_id="${TG_CHAT_ID}" \
            --data-urlencode text="$MSG"

          curl -sS -F chat_id="$TG_CHAT_ID" \
            -F document=@"${ZIP_NAME}" \
            "https://api.telegram.org/bot${TG_TOKEN}/sendDocument"

          curl -sS -F chat_id="$TG_CHAT_ID" \
            -F document=@kernel/build.log \
            "https://api.telegram.org/bot${TG_TOKEN}/sendDocument"

      - name: Telegram Failure
        if: ${{ env.SUCCESS == '0' && env.TG_TOKEN != '' && env.TG_CHAT_ID != '' }}
        shell: bash
        run: |
          set -euo pipefail
          test -f kernel/error.log || cp -f kernel/build.log kernel/error.log || true
          curl -sS -F chat_id="${TG_CHAT_ID}" \
            -F document=@kernel/error.log \
            -F caption="‚ùå Kernel build FAILED | Device=${{ inputs.device }} | KernelSU-Next=${{ inputs.kernelsu_next }}" \
            "https://api.telegram.org/bot${TG_TOKEN}/sendDocument"

      - name: Mark workflow failed if kernel build failed
        if: env.SUCCESS == '0'
        shell: bash
        run: exit 1
